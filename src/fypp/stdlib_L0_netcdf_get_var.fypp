#:include "../include/common.fypp"
#:include "../include/stdlib_netcdf.fypp"
!
! Level 0 NetCDF wrappers: No checks are performed, except
!                          the error check on exit
!
module stdlib_L0_netcdf_get_var

    implicit none
    !
    ! Generic name: nc_get_var
    !
    interface nc_get_var
       #:for k1, t1, n1 in (netCDF_REAL_KINDS_TYPES)
       
       #:for d in range(netCDF_MAXDIMS)
       module procedure netCDF_get_var_${d}$D_${k1}$
       #:endfor 
       #:endfor

    end interface

contains 

   #:for k1, t1, n1 in (netCDF_REAL_KINDS_TYPES)
   !
   !   Routine: netCDF_get_var_XD_${k1}$
   ! Precision: ${k1}$
   !      Type: ${t1}$
   ! 
   #:for d in range(netCDF_MAXDIMS)
   !    Rank ${d}$: netCDF_get_var_${d}$D_${k1}$
   !
   subroutine netCDF_get_var_${d}$D_${k1}$( ncId, varId, values#{if d > 0}#, start, count, stride, map #{endif}#)
      USE stdlib_kinds, only: ${k1}$
      USE netcdf, only: nf90_get_var
      !
      integer,            intent(in   ) :: ncID
      integer,            intent(in   ) :: varID
      ${t1}$,           intent(  out) :: values${netCDF_Ranks[d]}$
#:if d > 0
      integer,  optional, intent(in   ) :: start(${d}$)
      integer,  optional, intent(in   ) :: count(${d}$)
      integer,  optional, intent(in   ) :: stride(${d}$)
      integer,  optional, intent(in   ) :: map(${d}$)
#:endif
      !
      integer :: ierr
      !
      ierr = nf90_get_var( ncId, varId, values#{if d > 0}#, start, count, stride, map #{endif}#) !${d}$D_${k1}$
      if ( ierr /= 0 ) ERROR STOP
      !
   end subroutine netCDF_get_var_${d}$D_${k1}$
   !
   #:endfor
   #:endfor
   !
end module stdlib_L0_netcdf_get_var
